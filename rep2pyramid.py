#!/usr/bin/env python
"""
Convert REPs to (X)HTML fragments for Pyramid - courtesy of /F

Usage: %(PROGRAM)s [options] [<reps> ...]

Options:

-d <DIR>, --destdir <DIR>
    Specify the base destination directory for Pyramid files.
    Default: %(SERVER_DEST_DIR_BASE)s

-f, --force
    Force the rebuilding of output files, regardless of modification times.

-k, --keep-going
    Continue building past errors if possible.

-q, --quiet
    Turn off verbose messages.

-h, --help
    Print this help message and exit.

The optional arguments ``reps`` are either rep numbers or .txt files.
"""

import sys
import os
import codecs
import re
import cgi
import glob
import getopt
import errno
import random
import time
import shutil

REQUIRES = {'python': '2.2',
            'docutils': '0.5'}
PROGRAM = sys.argv[0]
SERVER_DEST_DIR_BASE = (
    '/var/www/www.ros.org/html/reps')
RFCURL = 'http://www.faqs.org/rfcs/rfc%d.html'
REPSVNURL = 'http://code.ros.org/svn/rep/trunk/rep-%04d.txt'
REPDIRURL = '/reps/'
REPURL = REPDIRURL + 'rep-%04d'
REPANCHOR = '<a href="' + REPURL + '">%i</a>'

LOCALVARS = "Local Variables:"

COMMENT = """<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
REP, see http://ros.org/reps/rep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->"""

# The generated HTML doesn't validate -- you cannot use <hr> and <h3> inside
# <pre> tags.  But if I change that, the result doesn't look very nice...

fixpat = re.compile("((https?|ftp):[-_a-zA-Z0-9/.+~:?#$=&,]+)|(rep-\d+(.txt)?)|"
                    "(RFC[- ]?(?P<rfcnum>\d+))|"
                    "(REP\s+(?P<repnum>\d+))|"
                    ".")

CONTENT_HTML = """\
<n:invisible n:data="content" n:render="mapping">
<div id="breadcrumb" n:data="breadcrumb" n:render="breadcrumb" />
<n:slot name="text"></n:slot>
</n:invisible>
"""

CONTENT_YML = """\
--- !fragment
# Type of template to use
template: content.html

# The data to pass to the template
local:
    content:
        breadcrumb: !breadcrumb nav.yml nav
        text: !htmlfile body.html
"""

INDEX_YML = """\
--- !fragment
template: index.html
# The data to pass to the template
local:
  title: "%s"
  content: !fragment content.yml
"""

EMPTYSTRING = ''
SPACE = ' '
COMMASPACE = ', '


class Settings:

    # defaults:
    verbose = True
    keep_going = False
    force_rebuild = False
    dest_dir_base = SERVER_DEST_DIR_BASE

settings = Settings()


def usage(code, msg=''):
    """Print usage message and exit.  Uses stderr if code != 0."""
    if code == 0:
        out = sys.stdout
    else:
        out = sys.stderr
    print >> out, __doc__ % globals()
    if msg:
        print >> out, msg
    sys.exit(code)


def fixanchor(current, match):
    text = match.group(0)
    link = None
    if (text.startswith('http:') or text.startswith('https:')
        or text.startswith('ftp:')):
        # Strip off trailing punctuation.  Pattern taken from faqwiz.
        ltext = list(text)
        while ltext:
            c = ltext.pop()
            if c not in '();:,.?\'"<>':
                ltext.append(c)
                break
        link = EMPTYSTRING.join(ltext)
    elif text.endswith('.txt') and text <> current:
        link = REPDIRURL + os.path.splitext(text)[0] + '/' + text 
    elif text.startswith('rep-') and text <> current:
        link = os.path.splitext(text)[0] + ".html"
    elif text.startswith('REP'):
        repnum = int(match.group('repnum'))
        link = REPURL % repnum
    elif text.startswith('RFC'):
        rfcnum = int(match.group('rfcnum'))
        link = RFCURL % rfcnum
    if link:
        return '<a href="%s">%s</a>' % (cgi.escape(link), cgi.escape(text))
    return cgi.escape(match.group(0)) # really slow, but it works...


NON_MASKED_EMAILS = [
    'ros-users@code.ros.org',
    'ros-developers@code.ros.org',
    ]

def fixemail(address, repno):
    if address.lower() in NON_MASKED_EMAILS:
        # return hyperlinked version of email address
        return linkemail(address, repno)
    else:
        # return masked version of email address
        parts = address.split('@', 1)
        return '%s&#32;&#97;t&#32;%s' % (parts[0], parts[1])


def linkemail(address, repno):
    parts = address.split('@', 1)
    return ('<a href="mailto:%s&#64;%s?subject=REP%%20%s">'
            '%s&#32;&#97;t&#32;%s</a>'
            % (parts[0], parts[1], repno, parts[0], parts[1]))

def fixfile(inpath, input_lines, outfile):
    from email.Utils import parseaddr
    basename = os.path.basename(inpath)
    infile = iter(input_lines)
    # head
    header = []
    rep = ""
    title = ""
    for line in infile:
        if not line.strip():
            break
        if line[0].strip():
            if ":" not in line:
                break
            key, value = line.split(":", 1)
            value = value.strip()
            header.append((key, value))
        else:
            # continuation line
            key, value = header[-1]
            value = value + line
            header[-1] = key, value
        if key.lower() == "title":
            title = value
        elif key.lower() == "rep":
            rep = value

    if rep:
        title = "REP " + rep + " -- " + title
    r = random.choice(range(64))
    print >> outfile, COMMENT
    print >> outfile, '<div class="header">\n<table border="0" class="rfc2822">'
    for k, v in header:
        if k.lower() in ('author', 'discussions-to'):
            mailtos = []
            for part in re.split(',\s*', v):
                if '@' in part:
                    realname, addr = parseaddr(part)
                    if k.lower() == 'discussions-to':
                        m = linkemail(addr, rep)
                    else:
                        m = fixemail(addr, rep)
                    mailtos.append('%s &lt;%s&gt;' % (realname, m))
                elif part.startswith('http:'):
                    mailtos.append(
                        '<a href="%s">%s</a>' % (part, part))
                else:
                    mailtos.append(part)
            v = COMMASPACE.join(mailtos)
        elif k.lower() in ('replaces', 'replaced-by', 'requires'):
            otherreps = ''
            for otherrep in re.split(',?\s+', v):
                otherrep = int(otherrep)
                otherreps += REPANCHOR % (otherrep, otherrep)
            v = otherreps
        elif k.lower() in ('last-modified',):
            date = v or time.strftime('%Y-%m-%d',
                                      time.localtime(os.stat(inpath)[8]))
            if date.startswith('$' 'Date: ') and date.endswith(' $'):
                date = date[6:-2]
            try:
                url = REPSVNURL % int(rep)
                v = '<a href="%s">%s</a> ' % (url, cgi.escape(date))
            except ValueError, error:
                v = date
        elif k.lower() == 'content-type':
            url = REPURL % 9
            rep_type = v or 'text/plain'
            v = '<a href="%s">%s</a> ' % (url, cgi.escape(rep_type))
        elif k.lower() == 'version':
            if v.startswith('$' 'Revision: ') and v.endswith(' $'):
                v = cgi.escape(v[11:-2])
        else:
            v = cgi.escape(v)
        print >> outfile, ('  <tr><th class="field-name">%s:&nbsp;</th>'
                           '<td>%s</td></tr>' % (cgi.escape(k), v))
    print >> outfile, '</table>'
    print >> outfile, '</div>'
    need_pre = 1
    for line in infile:
        if line[0] == '\f':
            continue
        if line.strip() == LOCALVARS:
            break
        if line[0].strip():
            if not need_pre:
                print >> outfile, '</pre>'
            print >> outfile, '<h3>%s</h3>' % line.strip()
            need_pre = 1
        elif not line.strip() and need_pre:
            continue
        else:
            # REP 0 has some special treatment
            if basename == 'rep-0000.txt':
                parts = line.split()
                if len(parts) > 1 and re.match(r'\s*\d{1,4}', parts[1]):
                    # This is a REP summary line, which we need to hyperlink
                    url = REPURL % int(parts[1])
                    if need_pre:
                        print >> outfile, '<pre>'
                        need_pre = 0
                    print >> outfile, re.sub(
                        parts[1],
                        '<a href="/dev/reps/rep-%04d/">%s</a>' % (int(parts[1]),
                            parts[1]), line, 1),
                    continue
                elif parts and '@' in parts[-1]:
                    # This is a rep email address line, so filter it.
                    url = fixemail(parts[-1], rep)
                    if need_pre:
                        print >> outfile, '<pre>'
                        need_pre = 0
                    print >> outfile, re.sub(
                        parts[-1], url, line, 1),
                    continue
            line = fixpat.sub(lambda x, c=inpath: fixanchor(c, x), line)
            if need_pre:
                print >> outfile, '<pre>'
                need_pre = 0
            outfile.write(line)
    if not need_pre:
        print >> outfile, '</pre>'
    return title

docutils_settings = None
"""Runtime settings object used by Docutils.  Can be set by the client
application when this module is imported."""

def fix_rst_rep(inpath, input_lines, outfile):
    from docutils import core
    parts = core.publish_parts(
        source=''.join(input_lines),
        source_path=inpath,
        destination_path=outfile.name,
        reader_name='rep',
        parser_name='restructuredtext',
        writer_name='rep_html',
        settings=docutils_settings,
        # Allow Docutils traceback if there's an exception:
        settings_overrides={'traceback': 1})
    outfile.write(parts['whole'])
    title = 'REP %s -- %s' % (parts['repnum'], parts['title'][0])
    return title

def get_rep_type(input_lines):
    """
    Return the Content-Type of the input.  "text/plain" is the default.
    Return ``None`` if the input is not a REP.
    """
    rep_type = None
    for line in input_lines:
        line = line.rstrip().lower()
        if not line:
            # End of the RFC 2822 header (first blank line).
            break
        elif line.startswith('content-type: '):
            rep_type = line.split()[1] or 'text/plain'
            break
        elif line.startswith('rep: '):
            # Default REP type, used if no explicit content-type specified:
            rep_type = 'text/plain'
    return rep_type

def get_input_lines(inpath):
    try:
        infile = codecs.open(inpath, 'r', 'utf-8')
    except IOError, e:
        if e.errno <> errno.ENOENT: raise
        print >> sys.stderr, 'Error: Skipping missing REP file:', e.filename
        sys.stderr.flush()
        return None, None
    lines = infile.read().splitlines(1) # handles x-platform line endings
    infile.close()
    return lines

def find_rep(rep_str):
    """Find the .txt file indicated by a cmd line argument"""
    if os.path.exists(rep_str):
        return rep_str
    num = int(rep_str)
    return "rep-%04d.txt" % num

def make_html(inpath):
    input_lines = get_input_lines(inpath)
    rep_type = get_rep_type(input_lines)
    if rep_type is None:
        print >> sys.stderr, 'Error: Input file %s is not a REP.' % inpath
        sys.stdout.flush()
        return None
    elif not REP_TYPE_DISPATCH.has_key(rep_type):
        print >> sys.stderr, ('Error: Unknown REP type for input file %s: %s'
                              % (inpath, rep_type))
        sys.stdout.flush()
        return None
    elif REP_TYPE_DISPATCH[rep_type] == None:
        rep_type_error(inpath, rep_type)
        return None
    destDir, needSvn, repnum = set_up_pyramid(inpath)
    outpath = os.path.join(destDir, 'body.html')
    if ( not settings.force_rebuild
         and (os.path.exists(outpath) 
              and os.stat(inpath).st_mtime <= os.stat(outpath).st_mtime)):
        if settings.verbose:
            print "Skipping %s (outfile up to date)"%(inpath)
        return
    if settings.verbose:
        print inpath, "(%s)" % rep_type, "->", outpath
        sys.stdout.flush()
    outfile = codecs.open(outpath, "w", "utf-8")
    title = REP_TYPE_DISPATCH[rep_type](inpath, input_lines, outfile)
    outfile.close()
    os.chmod(outfile.name, 0664)
    write_pyramid_index(destDir, title)
    # for REP 0, copy body to parent directory as well
    if repnum == '0000':
        shutil.copyfile(outpath, os.path.join(destDir, '..', 'body.html'))
    copy_aux_files(inpath, destDir)
    return outpath

def set_up_pyramid(inpath):
    m = re.search(r'rep-(\d+)\.', inpath)
    if not m:
        print >>sys.stderr, "Can't find REP number in file name."
        sys.exit(1)
    repnum = m.group(1)
    destDir = os.path.join(settings.dest_dir_base, 'rep-%s' % repnum)

    needSvn = 0
    if not os.path.exists(destDir):
        needSvn = 1
        os.makedirs(destDir)

        #  write content.html
        foofilename = os.path.join(destDir, 'content.html')
        fp = codecs.open(foofilename, 'w', 'utf-8')
        fp.write(CONTENT_HTML)
        fp.close()
        os.chmod(foofilename, 0664)

        #  write content.yml
        foofilename = os.path.join(destDir, 'content.yml')
        fp = codecs.open(foofilename, 'w', 'utf-8')
        fp.write(CONTENT_YML)
        os.chmod(foofilename, 0664)
    return destDir, needSvn, repnum

def write_pyramid_index(destDir, title):
    filename = os.path.join(destDir, 'index.yml')
    fp = codecs.open(filename, 'w', 'utf-8')
    title = title.replace('\\', '\\\\') # Escape existing backslashes
    fp.write(INDEX_YML % title.replace('"', '\\"'))
    fp.close()
    os.chmod(filename, 0664)

def copy_aux_files(rep_path, dest_dir):
    """
    Copy auxiliary files whose names match 'rep-XXXX-*.*'.
    """
    dirname, repname = os.path.split(rep_path)
    base, ext = os.path.splitext(repname)
    files = glob.glob(os.path.join(dirname, base) + '-*.*')
    for path in files:
        filename = os.path.basename(path)
        dest_path = os.path.join(dest_dir, filename)
        print '%s -> %s' % (path, dest_path)
        shutil.copy(path, dest_path)


REP_TYPE_DISPATCH = {'text/plain': fixfile,
                     'text/x-rst': fix_rst_rep}
REP_TYPE_MESSAGES = {}

def check_requirements():
    # Check Python:
    try:
        from email.Utils import parseaddr
    except ImportError:
        REP_TYPE_DISPATCH['text/plain'] = None
        REP_TYPE_MESSAGES['text/plain'] = (
            'Python %s or better required for "%%(rep_type)s" REP '
            'processing; %s present (%%(inpath)s).'
            % (REQUIRES['python'], sys.version.split()[0]))
    # Check Docutils:
    try:
        import docutils
    except ImportError:
        REP_TYPE_DISPATCH['text/x-rst'] = None
        REP_TYPE_MESSAGES['text/x-rst'] = (
            'Docutils not present for "%(rep_type)s" REP file %(inpath)s.  '
            'See README.txt for installation.')
    else:
        installed = [int(part) for part in docutils.__version__.split('.')]
        required = [int(part) for part in REQUIRES['docutils'].split('.')]
        if installed < required:
            REP_TYPE_DISPATCH['text/x-rst'] = None
            REP_TYPE_MESSAGES['text/x-rst'] = (
                'Docutils must be reinstalled for "%%(rep_type)s" REP '
                'processing (%%(inpath)s).  Version %s or better required; '
                '%s present.  See README.txt for installation.'
                % (REQUIRES['docutils'], docutils.__version__))

def rep_type_error(inpath, rep_type):
    print >> sys.stderr, 'Error: ' + REP_TYPE_MESSAGES[rep_type] % locals()
    sys.stdout.flush()

def build_reps(args=None):
    if args:
        filenames = rep_filename_generator(args)
    else:
        # do them all
        filenames = glob.glob("rep-*.txt")
        filenames.sort()
    for filename in filenames:
        try:
            make_html(filename)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print "While building REPs: %s" % filename
            if settings.keep_going:
                ee, ev, et = sys.exc_info()
                traceback.print_exception(ee, ev, et, file=sys.stdout)
                print "--keep-going/-k specified, continuing"
                continue
            else:
                raise

def rep_filename_generator(args):
    for rep in args:
        filename = find_rep(rep)
        yield filename

def main(argv=None):
    check_requirements()

    if argv is None:
        argv = sys.argv[1:]

    try:
        opts, args = getopt.getopt(
            argv, 'hd:fkq',
            ['help', 'destdir=', 'force', 'keep-going', 'quiet'])
    except getopt.error, msg:
        usage(1, msg)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-d', '--destdir'):
            settings.dest_dir_base = arg
        elif opt in ('-f', '--force'):
            settings.force_rebuild = True
        elif opt in ('-k', '--keep-going'):
            settings.force_rebuild = True
        elif opt in ('-q', '--quiet'):
            settings.verbose = False

    build_reps(args)


if __name__ == "__main__":
    main()
