REP: 2009
Title: Type Negotiation Feature
Author: Audrow Nash <audrow@openrobotics.org>, Chris Lalancette <clalancette@openrobotics.org>, Gonzalo de Pedro <gonzalodepedro@ekumenlabs.com>, William Woodall <william@openrobotics.org>
Status: Accepted
Type: Standards Track
Content-Type: text/x-rst
Created: 04-Nov-2021
Post-History:

Abstract
========

This REP proposes an extension to ROS 2 Lifecycle Nodes that will make it possible to negotiate the message types used by publishers and subscribers.


Motivation
==========

The primary reason for this change is to allow nodes to publish different types of messages that better allow the system to optimize its behavior.
For example, a publisher or subscriber may be more efficient with one image format (say, YUV420) than another (say, ARGB888).
What's more, the optimal message type to publish may change over time, if say, a different part of the ROS 2 network becomes active to accomplish a different task.
Perhaps the node with the original subscriber is no longer needed so the node goes into an idle mode, and another node with a different subscriber would prefer images in ARGB888, over YUV420, for resource reasons.
Currently, this behavior could be accomplished with ROS 2 nodes or lifecycle nodes, however doing so would require a significant amount of work for the programmer and are potential sources of errors.

A second reason for this change is that it can improve developer experience by giving the developer more flexibility in how they interface with different nodes.
The result of which is that they may need to spend less time writing code to convert a message type into the one message type accepted by the node they're using; instead the node may support additional types, so they may not need to perform any conversion.
This may reduce the number of errors in the user's code, as well as it may allow them to prototype more efficiently, as they may not have to write as much code to perform conversions.

The final reason for this change is that it will enable vendors of hardware accelerators to provide the most efficient operations.
That is, it may be the case that a node can do hardware-accelerated operations on a YUV420 image, but (slower) CPU conversions on a ARGB8888 image.
In that case, the hardware vendor's node would mark a preference on YUV420 since that uses the hardware more efficiently.


Terminology
===========

:Regular Publisher:
  A publisher that publishes a single message type on a single topic.

:Regular Subscriber:
  A subscriber that subscribes to a single message type on a single topic.

:Supported Message Type:
  A message type that can be selected for use during negotiation.

:Supported Message Priority Map:
  A data structure that maps supported message types to their respective priority.
  The exact function used to determine how to use these priorities can be overwritten by the user.
  In general, higher numbers indicate higher priority, zero indicates no preference, and negative numbers indicate a vote against using a supported message type.

:Selected Message Type:
  A supported type that has been selected for use during negotiation.

:Negotiating Publisher:
  A publisher with preferences as to which supported message type it prefers to publish.
  It can publish one or more selected message types on the same number of topics.

:Negotiating Subscriber:
  A subscriber with preferences as to which supported message type it prefers to subscribe to.
  It subscribes to a single selected message type on a single topic.

:Negotiating Publisher and Subscriber Pair:
  A singe node that has pair of negotiating publishers and subscribers that are related to each other in that the subscribers preferences may be based on the selected message type of the publisher.
  An example would be if the subscriber receives data, modifies it, and then publishes it.
  In this case, it is desirable to have the publisher and subscriber use the same selected message type.
  However, the selected message type may not be known before the publisher negotiates it.

Specification
=============

High-level Goals
----------------

The proposed change has a few goals:

- Provide a way for nodes to publish different types of messages.
- Support publishing in multiple formats at the same time.
- Only necessary publishers and subscribers are active at any given time.
- A publisher or subscriber can delay stating its preferences to wait for additional information.
- Core functions are exposed to the user to overwrite, namely the ability to choose how priorities are used to pick the selected message types and the ability to delay stating preferences.


Defining Supported Message Types
--------------------------------

For each supported message type, the following information must be known:

- The topic that the supported message type should be published on.
- The message type that will be sent (either a ROS 2 message type, such as  ``sensor_msgs::msg::Image``, or a custom data type).
- The relative priority of the supported message type.

The message type is important because multiple supported message types may be sent with the same ROS 2 message type.
For example, a publisher may publish image data in the format of YUV420 or ARGB8888, both of which could be sent in a ``sensor_msgs::msg::Image``.

Once there is a set of supported message types, negotiating publishers and subscribers can negotiate which type they prefer.


Defining Negotiating Publishers and Subscribers
-----------------------------------------------

Negotiating publishers and subscribers both require a list of supported message types and a service topic that will be used to negotiate the selected message types.

While negotiating publishers and subscribers reveal their supported type priority map by default, a user may provide a function that returns a supported type priority map.
This function may be useful to allow negotiating publishers and subscribers to introspect the system before stating their preferences, including available hardware and compute resources.
This function is blocking and thus can delay the negotiation process.

A special case of using a function to return a supported type priority map is when there is a negotiating publisher and subscriber pair, which is useful when the publisher and subscriber should ideally use the same supported message type.
In this case, the user should define a function that will prioritize the supported message types based on the selected message type of the publisher.

One thing to note is that there are potentially many combinations of supported message types in negotiating publisher and subscriber pairs.
For example, if there are four supported types for a negotiating publisher and subscriber and the developer wants to support all combinations, then the developer must implement six conversions between the supported message types (three choose two).
However, in the custom function for the negotiating subscriber, the developer can choose not to include supported types that there are not conversions for.
In the minimal case, the developer can just return a single supported type for the negotiating subscribers priority map: the publisher's selected message type.


Negotiation Algorithm
---------------------

Negotiating Publisher
^^^^^^^^^^^^^^^^^^^^^

The negotiating publisher will select zero or more supported message types (zero when publisher and subscribers have incompatible supported message types).
To do this, the negotiating publisher performs the following steps:

#. Use DDS discovery to find all the connected subscribers that are using the user specified service topic.

#. Query all connected subscribers for their supported message priority maps.

   - This can timeout if a negotiating subscriber delays stating its preferences indefinitely, for example if there is a deadlock.

#. Decide the selected message types by considering the subscribers and the publisher's own supported message priority maps.

   - This can result in zero or more matches, as mentioned above.
     In the case that there are zero matches, an error should be thrown.

   - Note that the publisher can also block here before it reveals its supported message types.
     This may be useful to query system information that may inform the priority values in the publisher's supported message priority map.

#. Notify all of the connected negotiating subscribers of the selected message types.

   - If there are multiple matches, the subscriber will select the one with the highest priority in its own supported message priority map.
     In the case that the multiple messages are of the same priority to the subscriber, the negotiating subscriber will choose a selected message type randomly.

#. The negotiating publisher then creates a publisher for each supported message type.

Note that all of the above occurs in an extended version of a lifecycle node.
The following algorithm occurs when the lifecycle is transitioning to the active state.
Specifically, this algorithm occurs in the callback when the node is activating.


Negotiating Subscriber
^^^^^^^^^^^^^^^^^^^^^^

The negotiating subscriber will send its supported message priority map to the negotiating publisher when queried and then wait on the negotiating publisher to tell it the selected message types.
During this time, the negotiating subscriber, which will also be an extension of a lifecycle node, will be transitioning from inactive to active.
Upon receiving the selected message types, the subscriber will create one subscriber.
If multiple selected message types are received, the subscriber will pick the one that has the highest priority in its own supported message priority map.
If the selected message types have equal priority, the subscriber will choose a selected message type randomly.
Once the subscriber has been created, the negotiating subscriber will enter the active state.


Negotiating Publisher and Subscriber Pair
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The negotiating publisher and subscriber pair is a single node that has both a negotiating publisher and subscriber.
In this case, the negotiating subscriber will wait on the negotiating publisher to pick selected message types and then make it's supported message priority map based on the publisher selected message types.
Doing so allows the negotiating subscriber to prioritize the selected message types of the publisher, which may be desirable for efficient data transfer.

The negotiating publisher and subscriber pair operates much as described in the previous two sections, with one exception: the node will remain in the activating state until both the negotiating publisher's publishers and the negotiating subscriber's subscriber have been created.
At which point, the node will transition to the active state.

As in previous sections, if no change is required to the selected message types, the node will remain in the active state.


Renegotiating Selected Message Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the case that the ROS 2 network is changing, the negotiating publisher may need to renegotiate its selected message types.
The process looks similar to the original negotiation, however the negotiating publisher remains active until it determines that the selected messages must be changed.
If the selected messages must change, the negotiating publisher deactivates itself and destroys its publishers.
The negotiating publisher then becomes inactive and then activates again.
In the activation step, the negotiating publisher will notify its subscribers of the new selected message types on the user specified service topic and create new publishers for the selected message types.
When there is no change required in the selected types, the publisher will continue to be active.

If the selected messages are being negotiated for a negotiating publisher and subscriber pair, the algorithm will proceed much as described, except the entire node will be inactive until both the publishers and subscriber have been created.

Similarly, the negotiating subscriber may need to change its subscriber type.
Once the negotiating publisher relays the new selected message types, the subscriber decides if it needs to be updated.
If the selected type or types match the subscriber's current message type, the subscriber does nothing and continues to be active.
If the selected type or types do not match the subscriber's current message type, the subscriber deactivates itself and activates again.
While the negotiating subscriber is activating, it creates a new subscriber for the new selected message type.


User Defined Functions
^^^^^^^^^^^^^^^^^^^^^^

There are two types of functions in the negotiation process that the user can define:

:Stating preferences:
  A function to have a negotiating publisher or subscriber state its preferences, which may include a delay.
:Picking selected message types:
  A function to pick the selected message types from the publisher and subscribers supported message priority maps.

The function for stating preferences allows the user to make the negotiating publisher or subscriber have its preferences be conditioned on some aspect of the system's state.
For example, a negotiating publisher or subscriber may prefer a certain message type if a type of hardware is available, for example a GPU.
This function is blocking and thus can delay the negotiation process.
One special case for this function is when there is a negotiating publisher and subscriber pair, which is useful when the publisher and subscriber should ideally use the same supported message type.
In this case, the user should define a function that will prioritize the supported message types based on the selected message type of the publisher.

The function for picking selected message types is used to determine which of the supported message types the negotiating publisher or subscriber should use and is run in the negotiating publisher.
Exposing this function allows the user to create a custom way to pick between supported types with different priorities.
This may be useful to make high priorities count for relatively more weight in choosing a supported type or having normalized priorities (e.g., between 0 and 1).


Negotiation Examples
--------------------

Using the following notation, let ``N_n(T_1, T_2, ..., T_m)`` be node ``n``, where ``n`` is a positive integer, and let the arguments in parentheses, ``T_1, T_2, ..., T_m``, be the supported message types.
Note that there can be ``m`` supported types for each node, where ``m`` is a positive integer.
For convenience, let's also assume that the supported types are prioritized in their respective order, such that the priority of ``T_1`` is the highest, ``T_2`` is the second highest, and so on.

Using the node notation described above, we can then use the following notation to describe the agreed upon message type between multiple nodes.
In the example below, node ``1`` (``N_1``) supports only type ``x``, and node ``2`` (``N_2``) supports types ``x`` and ``y``.
In this case, the selected message type is ``x``, as shown by the ``x`` over the arrow pointing from node ``1`` to node ``2``.
More practically, ``N_1`` is publishing ``x``, and ``N_2`` is subscribing to a topic with the selected message type ``x``.

.. code-block::

            x
   N_1(x) ----> N_2(x, y)


Simple Examples
^^^^^^^^^^^^^^^

We can now use this notation to reason about the agreed upon the selected message type in several different scenarios.
There are several cases that are clear.

.. code-block::

   (1a)
                    x
           N_1(x) ----> N_2(x)

   (1b)

           N_1(x) ----> N_2(y)  # FAILED NEGOTIATION

   (1c)
                    y
           N_1(y) ----> N_2(x, y)

   (1d)
                    x
        N_1(x, y) ----> N_2(x)

   (1e)
                    y
        N_1(x, y) ----> N_2(y)

   (1f)
                    x
     N_1(x, y, z) ----> N_2(x, a, b)

   (1g)
                    x
     N_1(x, y, z) ----> N_2(a, b, x)


Publishing to Multiple Nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are also the cases where there are more than two nodes.

In the following case, ``N_3`` has the limiting supported type, ``y``, so ``N_1`` will publish ``y``, despite the fact that both ``N_1`` and ``N_2`` prefer ``x``.
This is assuming that the function for picking the selected types prioritizes sending one message over sending multiple messages.

.. code-block::

   (2a)
                 y
     N_1(x, y) -------> N_2(x, y)
                    |
                    |-> N_3(y)

In the following case, the two nodes receiving data from ``N_1`` both require different message types.
Thus, ``N_1`` has two selected message types, ``x`` and ``y``, and thus ``N_1`` has two publishers.

.. code-block::

   (2b)
                 x
     N_1(x, y) ----> N_2(x)
             |
             |   y
             |-----> N_3(y)


Negotiating Publisher and Subscriber Pairs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To discuss negotiating publisher and subscriber pairs, we'll have to use additional notation.
The following notation shows the result of a custom function that uses the negotiating publishers selected message type to decide the supported message priority map for the negotiating subscriber.

Let ``N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})`` be a node ``p`` thats negotiating publishers and subscribers.
The first argument ``[x, y, z]`` is the prioritized supported type map for the negotiating publisher, that is, in this case, the negotiating publisher prefers ``x`` more than ``y``, and ``y`` more than ``z``.
The second argument ``{x: [x, y, z], y: [y, z, x], z: [z, x, y]}`` is the prioritized supported type map for the negotiating subscriber.
This second argument is in the form of a dictionary (``{key1: value1, key2: value2, ...}``), where

* the key is the selected message type of the negotiating publisher in the negotiating publisher subscriber pair and
* the value is the prioritized supported type map for the negotiating subscriber given that key.

For example, for the node ``N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})``, if the negotiating publisher negotiates with its subscribers and determines that the selected message type is ``y``, then the negotiating subscriber in the negotiating publisher subscriber pair will state its supported message priority map as ``[y, z, x]``.
This is because in the second argument (the negotiating subscribers preference map) the key ``y`` is mapped to the value ``[y, z, x]``.
Similarly, if the publisher chooses ``z``, then the subscriber will use the supported message priority map of ``[z, x, y]``.

As a shorthand in figures, we'll define a node that differs its preference beforehand and add an asterisk to separate it from other nodes. For example:

.. code-block::

    N_p*(x, y, z) := N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

or

.. code-block::

    N_p* := N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

Also, note that regular nodes with the standard notation (e.g., ``N_n(x, y, z)``, with no ``*``) reveal their preferences when queried.

.. code-block::

   (3a)

     N_2*(x, y, z) := N_2([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

                    y                   y
     N_1(x, y, z) ----> N_2*(x, y, z) ----> N_3(y, z, x)

This approach can also be useful in networks that contain loops.
In the case below, node ``2`` will cause node ``1`` to wait to pick its preference until it has determined its selected message type.

.. code-block::

   (3b)

     N_2*(x, y, z) := N_2([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

                     y
                  |--------------------------
                  |                         |
                  |                     y   v
     N_1(x, y, z) ----> N_2*(x, y, z) ----> N_3(y, z, x)


It is possible with this method to have a deadlock.
In the following case all nodes will delay their preference indefinitely.
In this case, the only way out will be a timeout.

.. code-block::

   (3c)

     N_1* := N_1([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})
     N_2* := N_1*
     N_3* := N_1*

       -- N_3* <--
       |         |
       v         |
     N_1* ----> N_2*

Notice, however, that the deadlock is fixed by one node readily revealing its preferences.

.. code-block::


   (3d)

     N_1* := N_1([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})
     N_2* := N_1*

       -- N_3(x, y, z) <--
     x |                 |
       v    x          x |
     N_1* ----> N_2* -----


Rationale
=========

Having the Publisher Pick the Message Type
------------------------------------------

Consider a network with ``m`` negotiating publishers and ``n`` negotiating subscribers, where ``m`` and ``n`` are positive integers.
Also imagine that there are at least two publishers that are publishing with the same selected message type.
In this case, it is possible to have each of the negotiating publishers consider the other negotiating publishers in their decision of what message type to send.

It is also true that loops in the network may occur.
For example, imagine nodes ``A``, ``B``, and ``C``.
``A`` sends a message to ``B``, and ``B`` sends a message to ``C``.
This gets more complicated if ``A`` also sends a message to ``C``.

In both of the above cases, it is much more challenging to find the best selected message type than the simple strategy detailed in a previous section.
It was thought that the simpler approach described above in the specifications gets us almost all the way there, while being much simpler to implement.
In addition, if it turns out to be necessary, the simpler approach can always be replaced by a better method for getting the optimal selected message type in future work.


To Take a Centralized or Decentralized Approach
-----------------------------------------------

The specification above takes a decentralized approach to negotiating publishers and subscribers.
That is, each negotiating publisher and subscriber negotiates its own selected message type.
It is also possible to take a centralized approach, where all publishers and subscribers broadcast their preferences to a higher system that decides the selected message types.

The primary advantage of a decentralized approach is that it is easier to implement, especially given the greedy approach that we are using in computing the selected message type.
If we wanted to find the optimal selected message types taking the entire system into account, we would most likely have to implement a centralized approach, which would have a full understanding of the entire system before making a decision.


Extending Lifecycle Nodes
-------------------------

Very much of the stateful behavior that is required for the negotiation process is implemented in lifecycle nodes.
It also allows us to turn off nodes and free up the nodes resources should another task require those resources.
Thus it was an easy decision to extend the lifecycle nodes to with the negotiation process.


Putting this Implementation in ``rclcpp`` or ``rcl``
----------------------------------------------------

This feature is intended to be used with type adaptation (see `REP 2007 <./rep-2007.html>`_), which has been implemented in ``rclcpp``.
Thus it makes sense to put the negotiation process in ``rclcpp``.
As with REP 2007, the C++'s templating system will make it much easier to handle the various message types expected safely.


Backwards Compatibility
=======================

The proposed feature adds new functionality while not modifying existing functionality.


Feature Progress
================

Currently, there has been some prototyping to understand how the proposed feature may look using C++ features.

- `@audrow/type-negotiation-type-mapping <https://replit.com/@audrow/type-negotiation-type-mapping>`_ shows how the proposed feature may use C++ templating and a type map class to access publishers and subscribers.
  Note that the types used in this approach will have to be replaced with ``structs`` in the future to allow for multiple supported types to use the same ROS Message type.
- `@audrow/type-negotiation-possible-usage <https://replit.com/@audrow/type-negotiation-possible-usage>`_ shows another approach which uses inheritance to implement the proposed feature.
  This approach requires some additional work from the user to implement functions that create typed publishers and subscribers.

Perhaps the best way to proceed is in combining both of the approaches above, so that multiple supported types can use the same ROS Message type and the user doesn't need to implement as much boilerplate code.


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End: