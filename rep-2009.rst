REP: 2009
Title: Type Negotiation Feature
Author: Audrow Nash <audrow@openrobotics.org>, Chris Lalancette <clalancette@openrobotics.org>, Gonzalo de Pedro <gonzalodepedro@ekumenlabs.com>, William Woodall <william@openrobotics.org>
Status: Accepted
Type: Standards Track
Content-Type: text/x-rst
Created: 04-Nov-2021
Post-History:

Abstract
========

This REP proposes an extension to ROS 2 Lifecycle Nodes that will make it possible to negotiate the message types used by publishers and subscribers.


Motivation
==========

The primary reason for this change is to allow nodes to publish different types of messages that better allow the system to optimize its behavior.
For example, a publisher or subscriber may be more efficient with one image format (say, YUV420) than another (say, ARGB888).
What's more, the optimal message type to publish may change over time, if say, a different part of the ROS 2 network becomes active to accomplish a different task.
Perhaps the node with the original subscriber is no longer needed so the node goes into an idle mode, and another node with a different subscriber would prefer images in ARGB888, over YUV420, for resource reasons.
Currently, this behavior could be accomplished with ROS 2 nodes or lifecycle nodes, however doing so would require a significant amount of work for the programmer and are potential sources of errors.

A second reason for this change is that it can improve developer experience by giving the developer more flexibility in how they interface with different nodes.
The result of which is that they may need to spend less time writing code to convert a message type into the one message type accepted by the node they're using; instead the node may support additional types, so they may not need to perform any conversion.
This may reduce the number of errors in the user's code, as well as it may allow them to prototype more efficiently, as they may not have to write as much code to perform conversions.

The final reason for this change is that it will enable vendors of hardware accelerators to provide the most efficient operations.
That is, it may be the case that a node can do hardware-accelerated operations on a YUV420 image, but (slower) CPU conversions on a ARGB8888 image.
In that case, the hardware vendor's node would mark a preference on YUV420 since that uses the hardware more efficiently.


Terminology
===========

:Regular Publisher:
  A publisher that publishes a single message type on a single topic.

:Regular Subscriber:
  A subscriber that subscribes to a single message type on a single topic.

:Supported Message Type:
  A message type that can be selected for use during negotiation.

:Supported Message Priority Map:
  A data structure that maps supported message types to their respective priority.
  The exact function used to determine how to use these priorities can be overwritten by the user.
  In general, higher numbers indicate higher priority, zero indicates no preference, and negative numbers indicate a vote against using a supported message type.

:Selected Message Type:
  A supported type that has been selected for use during negotiation.

:Negotiating Publisher:
  A publisher with preferences as to which supported message type it prefers to publish.
  It can publish one or more selected message types, on the same number of topics.

:Negotiating Subscriber:
  A subscriber with preferences as to which supported message type it prefers to subscribe to.
  It subscribes to a single selected message type on a single topic.

:Negotiating Publisher and Subscriber Pair:
  A pair of negotiating publishers and subscribers that are related to each other in that the subscribers preferences may be based on the selected message type of the publisher.
  An example would be if the subscriber receives data, modifies it, and then publishes it.
  In this case, it is desirable to have the publisher and subscriber use the same selected message type.
  However, the selected message type may not be known before the publisher negotiates it.

Specification
=============

High-level Goals
----------------

The proposed change has a few goals:

- Provide a way for nodes to publish different types of messages.
- Support publishing in multiple formats at the same time.
- Only necessary publishers and subscribers are active at any given time.
- A publisher or subscriber can delay stating its preferences to wait for additional information.
- Core functions are exposed to the user to overwrite, namely the ability to choose how preferences are prioritized and the ability to delay stating preferences.


Defining Supported Message Types
--------------------------------

For each supported message type, the following information must be known:

- The topic that the supported message type should be published on.
- The message type that will be sent (either a ROS 2 message type, such as  ``sensor_msgs::msg::Image``, or a custom data type).
- The relative priority of the supported message type.

The message type is important because multiple message types may be sent with the same ROS 2 message type.
For example, a publisher may publish image data in the format of YUV420 or ARGB8888, both of which could be sent in a ``sensor_msgs::msg::Image``.

Once there is a set of supported message types, publishers and subscribers can negotiate which type they prefer.


Defining Negotiating Publishers and Subscribers
-----------------------------------------------

Negotiating publishers and subscribers both require a list of supported message types defined by the user.

While a default should be provided, the negotiating publisher can have the function it uses to prioritize the supported message types defined by the user.

Both the publisher and subscriber can delay stating their preferences until additional information is available.
Doing so may be useful to allow the publisher or subscriber to introspect the system before stating its preferences.
This function is exposed to the user.

A special case of delaying preferences is when there is a negotiating publisher and subscriber pair, which is useful when the publisher and subscriber should ideally use the same supported message type.
In this case, the user should define a function that will prioritize the supported message types based on the selected message type of the publisher.


Negotiation Algorithm
---------------------

Negotiating Publisher
^^^^^^^^^^^^^^^^^^^^^

The negotiating publisher will select zero or more supported message types (zero when publisher and subscribers have incompatible supported message types).
To do this, the negotiating publisher performs the following steps:

#. Query all connected subscribers for their supported message priority maps.
   - This can timeout if a negotiating subscriber delays stating its preferences indefinitely, for example if there is a deadlock.
#. Decide the selected message types by considering the subscribers and the publisher's own supported message priority maps.
   - This can result in zero or more matches, as mentioned above.
     In the case that there are zero matches, an error should be thrown.
   - Note that the publisher can also block here before it reveals its supported message types.
     This may be useful to query system information that may inform the priority values in the publisher's supported message priority map.
#. Notify all of the connected negotiating subscribers of the selected message types.
   - If there are multiple matches, the subscriber will select the one with the highest priority in its own supported message priority map.
     In the case that the multiple messages are of the same priority to the subscriber, the negotiating subscriber will choose a selected message type randomly.
#. The negotiating publisher then creates a publisher for each supported message type.

Note that all of the above occurs in an extended version of a lifecycle node.
The following algorithm occurs when the lifecycle is transitioning to the active state.
Specifically, this algorithm occurs in the callback when the node is activating.


Negotiating Subscriber
^^^^^^^^^^^^^^^^^^^^^^

The negotiating subscriber will send its supported message priority map to the negotiating publisher when queried and then wait on the negotiating publisher to tell it the selected message types.
During this time, the negotiating subscriber, which will also be an extension of a lifecycle node, will be transitioning from inactive to active.
Upon receiving the selected message types, the subscriber will create one subscriber.
If multiple selected message types are received, the subscriber will pick the one that has the highest priority in its own supported message priority map.
If the selected message types have equal priority, the subscriber will choose a selected message type randomly.
Once the subscriber has been created, the negotiating subscriber will enter the active state.


Negotiating Publisher and Subscriber Pair
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The negotiating publisher and subscriber pair is a single node that has both a negotiating publisher and subscriber.
In this case, the negotiating subscriber will wait on the negotiating publisher to pick selected message types and then make it's supported message priority map based on the publisher selected message types.
Doing so allows the negotiating subscriber to prioritize the selected message types of the publisher, which may be desirable for efficient data transfer.

The negotiating publisher and subscriber pair operates much as described in the previous two sections, with one exception: the node will remain in the activating state until both the negotiating publisher's publishers and the negotiating subscriber's subscriber have been created.
At which point, the node will transition to the active state.

As in previous sections, if no change is required to the selected message types, the node will remain in the active state.


Renegotiating Selected Message Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In the case that the ROS 2 network is changing, the negotiating publisher may need to renegotiate its selected message types.
The process looks similar to the original negotiation, however the negotiating publisher remains active until it determines that the selected messages must be changed.
If the selected messages must change, the negotiating publisher deactivates itself and destroys its publishers.
The negotiating publisher then becomes inactive and then activates again.
In the activation step, the negotiating publisher will notify its subscribers of the new selected message types and create new publishers for the selected message types.
When there is no change required in the selected types, the publisher will continue to be active.

If the selected messages are being negotiated for a negotiating publisher and subscriber pair, the algorithm will proceed much as described, except the entire node will be inactive until both the publishers and subscriber have been created.

Similarly, the negotiating subscriber may need to change its subscriber type.
Once the negotiating publisher relays the new selected message types, the subscriber decide if it needs to be updated.
If the selected type or types match the subscriber's current message type, the subscriber does nothing and continues to be active.
If the selected type or types do not match the subscriber's current message type, the subscriber deactivates itself and activates again.
While the negotiating subscriber is activating, it creates a new subscriber for the new selected message type.


Negotiation Examples
--------------------

Using the following notation, let ``N_n(T_1, T_2, ..., T_m)`` be node ``n``, where ``n`` is a positive integer, and let the arguments in parentheses, ``T_1, T_2, ..., T_m``, be the supported message types.
Note that there can be ``m`` supported types for each node, where ``m`` is a positive integer.
For convenience, let's also assume that the supported types are prioritized in their respective order, such that the priority of ``T_1`` is the highest, ``T_2`` is the second highest, and so on.

Using the node notation described above, we can then use the following notation to describe the agreed upon message type between multiple nodes.
In the example below, node ``1`` (``N_1``) supports only type ``x``, and node ``2`` (``N_2``) supports types ``x`` and ``y``.
In this case, the agreed upon message type is ``x``, as shown by the ``x`` over the arrow pointing from node ``1`` to node ``2``.
More practically, ``N_1`` is publishing ``x``, and ``N_2`` is subscribing to a topic with message type``x``.

.. code-block::

            x
   N_1(x) ----> N_2(x, y)

In some examples below we will reason about which message type should be chosen.
In such cases, ``??`` will be used to denote that we are not sure of the message type just yet.

Simple examples
^^^^^^^^^^^^^^^

We can now use this notation to reason about the agreed upon message type in several different scenarios.
There are several cases that are clear.

.. code-block::

   (1a)
                    y
           N_1(y) ----> N_2(x, y)

   (1b)
                    x
        N_1(x, y) ----> N_2(x)

   (1c)
                    y
        N_1(x, y) ----> N_2(y)

   (1d)
                    x
     N_1(x, y, z) ----> N_2(x, a, b)

   (1e)
                    x
     N_1(x, y, z) ----> N_2(a, b, x)

A case that depends on how priorities are calculated
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

And several cases that may depend on the implementation.
This case depends on how the voting is done.

.. code-block::

   (2a-1)
                   ??
     N_1(x, y, z) ----> N_2(z, y, x)

There may be different ways to prioritize preferences.
One example is simple voting scheme where every node has a priority that corresponds to its position (using zero as the first index), and the publisher breaks ties with its preference.

.. math::

   \text{priority} = \frac{1}{\text{position}+1}

If this is the case, the value of ``priority`` for node ``1``, the priority for ``x``, ``y``, and ``z`` is ``1/1``, ``1/2``, and ``1/3`` respectively.
And for node ``2`` the priority for ``z``, ``y``, and ``x`` is ``1/1``, ``1/2``, and ``1/3`` respectively.
This means that ``x`` and ``z`` have the same priority of ``4/3`` between nodes ``1`` and ``2``, and ``y`` has the same priority of ``1`` between nodes ``1`` and ``2``.
Since it is a tie between ``x`` and ``z``, the agreed upon message type is ``x``, since the publishers preference breaks ties, and the publisher, node ``1`` prefers type ``x``.

.. code-block::

   (2a-2)
                    x
     N_1(x, y, z) ----> N_2(z, y, x)

Publishing to multiple nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

There are also the cases where there are more than two nodes.

In the following case, ``N_3`` has the limiting supported type, ``y``, so ``N_1`` will publish ``y``, despite the fact that both ``N_1`` and ``N_2`` prefer ``x``.

.. code-block::

   (3a)
                 y
     N_1(x, y) -------> N_2(x, y)
                    |
                    |-> N_3(y)

In the following case, the two nodes receiving data from ``N_1`` both require different message types.
Thus, ``N_1`` will publish two different message types, ``x`` and ``y``.

.. code-block::

   (3b)
                 x
     N_1(x, y) ----> N_2(x)
             |
             |   y
             |-----> N_3(y)

Superposition for negotiating in loops
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In this case, we will use ``??`` to mean that the message type is unknown.
Note that we have two message types potentially coming from node ``1`` since it has two subscribers.

.. code-block::

   (4a-1)
                ??
            |-------------------------
            |                        |
            |   ??              ??   v
     N_1(x, y) ----> N_2(y, z) ----> N_3(y)

In this case, the above system can be thought using superposition, that is, solving the problem in parts.

.. code-block::

   (4a-2)
                 y
     N_2(y, z) ----> N_3(y)

and

.. code-block::

   (4a-3)
                 y
     N_1(x, y) -------> N_2(y, z)
                    |
                    |-> N_3(y)

Thus we get that both node 1 and node 2 will be publishing ``y``.

.. code-block::

   (4a-4)
                   y
               |----------------------
               |                     |
               |                y    v
     N_1(x, y) ----> N_2(y, z) ----> N_3(y)

There is also the case, where the solution by superposition yields two different message types for the subscriber.
This is unfortunate, and could be solved by having the publishing nodes coordinate or by having nodes that delay their revealing their preferences as discussed below.

.. code-block::

   (4b-1)
              ?
         |-------------------------
         |                        |
         |    ?               ?   v
     N_1(x) ----> N_2(z, x) ----> N_3(z, x)

The above system can be decomposed into the following steps.

.. code-block::

   (4b-2)
                 z
     N_2(z, x) ----> N_3(z, x)

and

.. code-block::

   (4b-3)
                 x
     N_1(x) -------> N_2(z, x)
                 |
                 |-> N_3(z, x)

If the publishers in node 1 and 2 were able to coordinate, they would have realized that ``x`` is the only solution that allows node 3 to have one subscriber message type.

.. code-block::

   (4b-4)
               x
            |----------------------
            |                     |
            |                 z   v
     N_1(x) ----> N_2(z, x) ----> N_3(z, x)

Nodes that delay revealing their preferences
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It may be the case that a node with both publishers and subscribers would like to wait to reveal its subscribers preferences until its publisher knows what message type it will be using.

To discuss this, we'll have to use additional notation.

Let ``N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})`` be a node ``p`` thats publishers and subscribers support ``x``, ``y``, and ``z`` message types, as given by the first argument.
Then let the second argument be a dictionary that maps each message type to an ordered preference.
This dictionary is used to determine the preference of node ``p``'s subscriber.

As a shorthand in figures, we'll define a node that differs its preference beforehand and add an asterisk to separate it from other nodes. For example:

.. code-block::

    N_p*(x, y, z) := N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

or

.. code-block::

    N_p* := N_p([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

Also, note that regular nodes with the standard notation (e.g., ``N_n(x, y, z)``, with no ``*``) readily reveal their preferences, which is to say that they don't delay revealing their preferences until their publisher has determined its message type.

.. code-block::

    N_2*(x, y, z) := N_2([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

   (5a)
                    y                   y
     N_1(x, y, z) ----> N_2*(x, y, z) ----> N_3(y, z, x)

This approach can also be useful in the problems solved above with superposition.
In the case below, node ``2`` will cause node ``1`` wait to pick its preference until it has determined its message type.

.. code-block::

    N_2*(x, y, z) := N_2([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})

   (5b)
                     y
                  |--------------------------
                  |                         |
                  |                     y   v
     N_1(x, y, z) ----> N_2*(x, y, z) ----> N_3(y, z, x)

It is possible with this method to have a deadlock.
In the following case all nodes will delay their preference indefinitely.
In this case, the only way out will be a timeout.

.. code-block::

    N_1* := N_1([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})
    N_2* := N_1*
    N_3* := N_1*

   (5c)

       -- N_3* <--
       |         |
       v         |
     N_1* ----> N_2*

Notice, however, that the deadlock is fixed by one node readily revealing its preferences.

.. code-block::

    N_1* := N_1([x, y, z], {x: [x, y, z], y: [y, z, x], z: [z, x, y]})
    N_2* := N_1*

   (5d)

       -- N_3(x, y, z) <--
     x |                 |
       v    x          x |
     N_1* ----> N_2* -----


Rationale
=========

Having the Publisher Pick the Message Type
------------------------------------------

Consider a network with ``m`` publishers and ``n`` subscribers, where ``m`` and ``n`` are positive integers.
Also imagine that there are at least two publishers that are publishing on the same topic.
In this case, it is possible to have each of these publishers consider the other publishers in their decision of what message type to send.

It is also true that loops in the network may occur.
For example, imagine nodes ``A``, ``B``, and ``C``.
``A`` sends a message to ``B``, and ``B`` sends a message to ``C``.
This gets more complicated if ``A`` also sends a message to ``C``.

In both of the above cases, it is much more challenging to find the best message type than the simple strategy detailed in a previous section.
It was thought that the simpler approach described above in the specifications gets us almost all the way there, while being much simpler to implement.
In addition, if it turns out to be necessary, the simpler approach can always be replaced by a better method for getting the optimal solution in future work.


Using Different Topics or the Same Topic For Different Message Types
--------------------------------------------------------------------

If a publisher can publish ``ARGB888`` or ``YUV420`` images, should the images be published on namespaced topics or to the topic directly?
Specifically, say that it has been negotiated the the publisher should publish ``ARG888`` on the topic ``/image``, should the images be published on ``/image/ARGB888`` or ``/image``?
In either case, the topics should support following remapping rules.
Using ``/image/ARGB888`` removes ambiguity, but could make it hard to work with other nodes that do not negotiate their message types that are also on the network.
It also will be harder to use with remapping rules.
While ``/image`` is cleaner, but may lead to confusion when a single topic is used for multiple message types.
``/image`` also makes it more difficult for the user to use topics published by nodes that do not perform type negotiation, which actually may be desirable: it will reduce the chance that the user builds a pipeline for one message type but then receives another message type on the same topic.

Since the ``<topic>/<message type>`` format removes ambiguity and makes it harder to use negotiated nodes inappropriately, we will use the ``<topic>/<message type>`` format for all topics.


Delaying Revealing Preferences Until the Publisher's Message Type is Known
--------------------------------------------------------------------------

In some cases, it may be desirable for a node that has both publishers and subscribers to delay revealing its preference until the publisher's message type is known.
This may be because data the subscriber receives may be used in the message that is ultimately published.

One danger in this behavior is that there may be a loop in which all nodes are delaying revealing their preferences.
A simple solution and the one proposed is to use a timeout to prevent this from happening.

If there is a case that there is a valid loop, then at least one of the nodes must reveal its preferences.
For this reason, nodes will have the ability to reveal their preferences or to delay revealing them.
For a node to delay revealing its preferences, there is additional configuration that must occur, so the default behavior will be that nodes reveal their preferences readily.


To Take a Centralized or Decentralized Approach
-----------------------------------------------

To come.


Extending Lifecycle Nodes
-------------------------

To come.


Putting this Implementation in ``rclcpp`` or ``rcl``
----------------------------------------------------

To come.


Backwards Compatibility
=======================

The proposed feature adds new functionality while not modifying existing functionality.


Feature Progress
================

To come.


References
==========

To come.


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End: